5:39:38 PM Олег Кац: Файловое хранилище – исходные данные для индексирования.
Есть файловое хранилище. В нём хранится и постоянно дописывается файлик, целиком состоящий из записей одинаковой структуры. Хранилище устроено так, что между записями могут образовываться дырки, заполненные произвольным говном. Чтобы отличать хорошие записи от говна, в начале записи ставится метка (4 константных байта), а в конце записи ставится контрольная сумма. Это делает не файловая система, а её клиенты. Файловой системе вообще на всё насрать. Файлик хранится разрезанным на куски по 64 мегабайта, каждый кусок в нескольких копиях. Полную карту расположения кусков файла знает (и умеет по запросу сообщать) специальный мастер-сервер файловой системы. Очевидно, что карта не является постоянной величиной, потому что файл дописывается, а сервера, на которых лежат куски файла, могут выходить из строя. Также очевидно, что карта является редко изменямой величиной, поэтому нужно придумать грамотную стратегию кэширования карты.  Чтобы узнать, где находится мастер-сервер, надо обратиться к DNS.

Обновление данных из файлового хранилища, индексный процесс и структура индекса.
Хранилище позволяет читать файл с любого заданного смещения. Этим нужно пользоваться, чтобы дочитывать из файла только те данные, которые туда дописались после последнего считывания. Далее, считанные данные разбираются (учитывая сказанное выше про говно) и помещаются в индекс, не блокируя доступ к индексу на чтение. Надо помнить, что объём считываемых данных может быть большим (например, при первоначальном запуске индекса необходимо прочитать весь файл в хранилище), поэтому не стоит сначала читать все данные, а потом разбирать их. Лучше организовать конвейерную обработку. С точки зрения клиентов индекса удобнее всего, чтобы к индексу можно было обращаться по http, и чтобы соответствующий http-сервер был "настоящим", то есть быстрым, многопоточным и отказоустойчивым. Отдельного внимания заслуживают ситуации, когда индекс целиком входит в память: надо уметь настраивать индексный сервер так, чтобы в таких случаях диск реально не использовался.

Восстановление индекса после сбоев.
В процессе работы индексного сервера надо создавать snapshot'ы, надёжно увязывая их со смещениями в файле. Snapshot – это данные произвольного вида, пользуясь которыми сервер может подняться значительно быстрее, чем читая исходный файл из хранилища с самого начала. Запуск сервера после сбоя начинается с поиска snapshot'ов и попыток восстановления. После удачного восстановления нужно дочитать файл из хранилища с заданного смещения. Только после этого нужно открыть доступ клиентам на чтение из индекса.

5:43:02 PM Олег Кац: Мелочи.
При индексировании прочитанной записи происходит следующее преобразование: в файле была записана структура A, а в индекс надо положить пару структур K (key) и V (value). Некоторые данные из структуры A будут невостребованы в индексе, некоторые должны быть преобразованы. Ну и надо указать, какие данные из структуры A являются ключом записи. Хорошо бы придумать разумную формализацию такого преобразования, чтобы не приходилось каждый раз писать отдельный код.
5:52:47 PM Ibragim Youldachev: Что есть?
5:52:58 PM Ibragim Youldachev: Какие требования к реализации?
5:53:23 PM Олег Кац: Считай, что ничего нет. Есть решения частного вида, то есть заточенные под конкретные структуры и условия.
5:53:39 PM Олег Кац: Что ты понимаешь под требованиями к реализации?
5:56:53 PM Ibragim Youldachev: Во-первых, что-то же должно уже быть. Иднексаторы, я не знаю, примеры структур и модификаций, язык запросов, требования к нагрузке. Требования к индексу и вообще назначение индекса. Кто и зачем пользуется индексом? Кто обеспечивает актуальность индекса по отношению к индексируемым файлам? Т.е. мы что делаем? Индексатор или поисковик? Где границы задачи?
5:57:35 PM Олег Кац: Ещё раз говорю. Ничего нет.
5:57:48 PM Олег Кац: Примеры сейчас сделаю.
5:58:44 PM Олег Кац: Языка запросов никакого нет. Надо уметь находить записи по префиксу ключа.
5:58:58 PM Олег Кац: Последняя фраза понятна?
5:59:04 PM Ibragim Youldachev: не очень.
5:59:23 PM Ibragim Youldachev: Стало известно, что у кюча есть префикс, но не понятно что это такое. ;)
5:59:36 PM Олег Кац: Префикс есть у чего угодно, не засоряй эфир
5:59:37 PM Ibragim Youldachev: Что значит "находить" тоже пока не понятно.
6:00:12 PM Олег Кац: Ну допустим, есть записи с ключами abc, acc и bcc. Запрос "найти" с параметром "a" должен вернуть первую и вторую записи.
6:00:25 PM Олег Кац: Найти – означает вернуть в http-ответе.
6:00:42 PM Ibragim Youldachev: запись? или её местоположение?
6:00:47 PM Олег Кац: Запись.
6:02:24 PM Олег Кац: Продолжаю отвечать на вопросы. 
Требования к нагрузке: сотни и тысячи запросов в секунду.
Требования к индексу – это что?
Назначение индекса: индексировать. То есть, быстро искать по ключу. Точнее, в нашем случае, по префиксу ключа.
6:03:28 PM Олег Кац: Объём индексируемых данных: гигабайты и десятки гигабайтов.
6:03:36 PM Ibragim Youldachev: т.е. индекс это информация о файле (его имя), структуре этого файла (описание записи, список ключевых полей(поля) и трансформации для записей из файла. Т.е. индекс уже будет хранить не данные, а что-то другое.
6:03:41 PM Олег Кац: "Кто обеспечивает актуальность индекса по отношению к индексируемым файлам?" – это вообще что?
6:06:08 PM Ibragim Youldachev: Поскольку я не очень понимаю какие операции можно производить над файлами и не очень хорошо помню механику ФС, то и не сразу могу понять как может "пострадать" индекс в зависимости от состояния ФС. Индекс во-перых может "отстать", а во-вторых рассинхронизироваться. Ещё он может сам по себе поломаться. Это как минимум.
6:06:55 PM Ibragim Youldachev: Тот кто управляет индексатором должен корректно обрабатывать все возможные сценарии.
6:07:14 PM Олег Кац: Давай рассмотрим пример. В файле лежат записи вида:
идентификатор организации (O) – идентификатор пользователя (U) – данные о пользователе (V)
известно, что пара O-U – это ключ записи

К индексу будут обращаться с запросами вида "O", тогда он должен будет вернуть все записи с заданным значением поля O и произвольным значением поля U (и V, естественно), и с запросами вида "OU", тогда он должен будет вернуть (скорее всего) единственную запись с заданными значениями O и U.
6:07:54 PM Олег Кац: С файлами нельзя производить никаких операций кроме чтения.
6:08:04 PM Олег Кац: Со стороны индекса.
6:08:32 PM Олег Кац: Индекс не может пострадать в зависимости от состояния ФС. Индекс страдает только сам по себе. Ломается.
6:08:53 PM Олег Кац: Вообще говоря, индекс будет немного отставать практически всегда. Это нормально.
6:09:00 PM Ibragim Youldachev: Это понятно, но кто-то ещё с ними что-то делает. И тот кто управляет индексом должен это учитывать. Заставляя индексатора обновить индекс.
6:09:32 PM Олег Кац: А, ну да, я этого не написал. Индекс (индексный процесс) сам периодически опрашивает файл на предмет изменений.
6:09:44 PM Олег Кац: Никаких внешних воздействий не применяется.
6:10:26 PM Олег Кац: То есть, в файл дописывают (а никаких других операций изменения данных не бывает), а индекс периодически дочитывает дописанные записи.
6:10:43 PM Олег Кац: Дочитывает дописанные записи и вносит изменения в свои внутренние структуры.
6:10:52 PM Олег Кац: К примеру вопросы есть?
6:10:58 PM Ibragim Youldachev: нет пока
6:11:50 PM Ibragim Youldachev: если я правильно помню, то в файле есть только одна операция -- дописать. Значит в файл "дописываются" удаления и модификации записей. Верно?
6:12:06 PM Олег Кац: В нашей задаче нет таких операций.
6:12:11 PM Олег Кац: У нас только дозапись.
6:12:18 PM Олег Кац: Нормальных новых данных.
6:12:43 PM Олег Кац: Но в принципе да, когда надо удалять или модифицировать, это делается так, как ты говоришь.
6:12:53 PM Ibragim Youldachev: А что если случается key violation?
6:13:02 PM Олег Кац: Это что означает?
6:13:09 PM Ibragim Youldachev: Нарушение ключа.
6:13:13 PM Олег Кац: violation – это нарушение. Нарушение чего?
6:13:22 PM Олег Кац: Что значит "нарушение ключа"?
6:13:25 PM Олег Кац: Даже звучит не по-русски
6:13:27 PM Ibragim Youldachev: Ты определил набор полей как ключ, а оно оказалось не уникальным.
6:13:35 PM Олег Кац: я же не сказал, что ключ уникален
6:13:59 PM Ibragim Youldachev: эээ... вообще-то обычно это определение ключа.
6:14:02 PM Олег Кац: Нет :-)
6:14:08 PM Олег Кац: Но предлагаю не спорить об этом.
6:14:14 PM Олег Кац: Ключ не является уникальным.
6:14:24 PM Ibragim Youldachev: Ладно.
6:14:40 PM Олег Кац: Тем более, когда надо искать по префиксу ключа, а не по целому ключу, уникальность ключа не играет никакой роли. Согласен?
6:14:53 PM Ibragim Youldachev: А файл может "откатиться"?
6:15:20 PM Ibragim Youldachev: Ну т.е. писали, писали. А потом всё ёбнулось и сказали что на самом деле не писали.
6:15:33 PM Олег Кац: Хороший вопрос. В нормальном режиме – нет. В результате какой-нибудь аварии – теоретически, может.
6:15:49 PM Олег Кац: Но мы в индексе ничего не сможем с этим поделать. Надо будет переиндексировать.
6:16:05 PM Олег Кац: И не автоматически, а руками.
6:16:06 PM Ibragim Youldachev: Иднексатор не понял, а за это время... ну, короче, shit happens.
6:16:18 PM Ibragim Youldachev: Понятно.
6:16:39 PM Ibragim Youldachev: Ты уверен, что не бывает удалений и модификаций? Вроде как это нетипично.
6:16:48 PM Ibragim Youldachev: Все люди, все ошибаются.
6:17:04 PM Олег Кац: А это принципиально?
6:17:32 PM Ibragim Youldachev: Да. Тогда есть ещё операции выбросить или обновить записи в индексе.
6:17:39 PM Олег Кац: А это принципиально?
6:17:57 PM Ibragim Youldachev: Да, это может повлиять на построение иднекса.
6:18:07 PM Олег Кац: Вот когда повлияет, тогда и вернёмся к этому вопросу.
6:19:15 PM Ibragim Youldachev: В стеке остался вопрос где это всё должно работать, на чём написано и пр. технические решения, которые ты уже принял.
6:23:46 PM Ibragim Youldachev: Ладно, я тоже отойду. Когда приду было бы здорово увидеть тут ответ на вопрос выше, твои соображения по поводу формата работы и... всё что ты захочешь сказать ещё. А я пока отлучусь и начну осознавать что ты тут написал.
6:26:03 PM Олег Кац: Предпочтительнее – C++ и мультиплатформенность. Ну а там на что ума хватит.
6:26:33 PM Олег Кац: В качестве собственно индекса лучше использовать какой-нибудь движок. Berkeley DB или SQLite. 
6:26:57 PM Олег Кац: Или что-нибудь еще, неважно.
6:30:03 PM Ibragim Youldachev: Раз ничего нет, то я вообще предлагаю делать прототип на каком-нить питоне. А потом заменять чего надо на С++ ну или С#. Интереснее, конечно, С++. 
По поводу SQLite у меня большие сомнения по поводу его способности держать большие индексы. Надо проверять.
6:31:31 PM Ibragim Youldachev: Щас надо понять как всё будет работать. А вот тут я бы предпочёл всё-таки доску и нормальное обсуждение. Ну или ты делаешь эту работу сам и выдаёшь изолированные задачи.
6:36:19 PM Ibragim Youldachev: Меня нет мин 15-20
6:37:28 PM Олег Кац: Ну давай Berkeley DB. По поводу него известно, что он прекрасно держит индексы любых размеров (в рамках нашей задачи).
6:37:51 PM Олег Кац: Если я не ошибаюсь, то к питону есть berkley-db-интерфейс.
6:38:08 PM Олег Кац: Если так, то это отличная идея.
6:38:44 PM Ibragim Youldachev: Да у питона ко всему насвете есть биндинги.
6:38:57 PM Олег Кац: Только вот одна проблема: 
6:39:14 PM Олег Кац: данные лежат в файлах (в хранилище) в бинарном виде
6:39:26 PM Олег Кац: Не знаю, как в питоне это разбирать.
6:39:36 PM Ibragim Youldachev: а где проблема?
6:39:49 PM Олег Кац: Не говорю, что это невозможно. Я просто не знаю, как в питоне разбирать двоичные данные.
6:40:30 PM Ibragim Youldachev: Не, такой проблемы там нет, насколько я знаю.
6:41:26 PM Ibragim Youldachev: Есть бинарные потоковые ридеры. То что прочитал можно конвертировать как минимум в строки. А строки, насколько я понимаю, это основные данные.
6:44:01 PM Олег Кац: Ну короче, у меня есть POD-структура на C. 
struct A {куча хуйни};
A a;
Я пишу её в файл методом write(file, &a, sizeof(a));
Как потом в питоне получить аналогичную структуру?
6:45:48 PM Олег Кац: http://docs.python.org/library/struct.html?highlight=struct#module-struct
6:45:52 PM Олег Кац: Кажется, так.
6:46:20 PM Ibragim Youldachev: Может пока оставим это? Оно решается.
У тебя дизанйн решения есть? Мне кажется, именно это то с чего стоит начать.
6:46:54 PM Олег Кац: Решается и ладно.
Что ты понимаешь под дизайном? Мне казалось, что то, что я рассказал, и есть (почти весь) дизайн.
6:47:04 PM Олег Кац: Декомпозиция-то уже сделана. 
6:50:56 PM Ibragim Youldachev: Ну хорошо, тогда я вижу первыми такие две задачи:

- формализация определения индекса.
- построение индекса (пакетная, с учётом остановов и, например, откатов).
6:51:03 PM Олег Кац: окей
6:51:37 PM Олег Кац: Давай формализуем. Надо определение в виде "индекс – это"?
6:52:16 PM Олег Кац: Я не понимаю таких вопросов. Давай лучше разбирать, что конкретно непонятно, оставляет вопросы, порождает чувство неуверенности и дискомфорта?
6:52:32 PM Олег Кац: Ну мы можем сейчас напыжиться и родить определение индекса. А что это даст?
6:53:29 PM Олег Кац: 

Для начала давай разграничим понятия индекса и индексного процесса. В силу естественной словарной редукции они будут часто смешиваться
6:54:33 PM Олег Кац: Индекс – это структура данных, обладающая [нужными нам] свойствами.
Индексный процесс – это http-сервер,  умеющий отвечать на [нужные нам] запросы, и используя для ответов на запросы [индекс].
6:55:44 PM Ibragim Youldachev: причём, я так понимаю что там два процесса: построение и ответы за запросы. Они вообще-то ортогональны.
6:55:47 PM Ibragim Youldachev: Но я не об этом.
6:56:21 PM Олег Кац: Так как запросы к http-серверу и операции дозаписи в индекс нужно производить параллельно, то разумно будет объединить эти активности в рамках одного процесса, одного адресного пространства.
6:56:27 PM Ibragim Youldachev: Я о метаинформации, которая будет определять структуру индеска при построении и запросах к нему.
6:57:30 PM Олег Кац: Итак, приходим к тому, что индексный процесс – это с одной стороны  http-сервер, а с другой – клиент файлового хранилища. И внутри у него живёт индекс.
6:57:36 PM Олег Кац: Теперь о метаинформации
6:57:48 PM Олег Кац: Вот на этот вопрос у меня нет ответа вообще.
6:57:51 PM Ibragim Youldachev: На мой взгляд, объединение в один процесс сделает чуть более эффективной синхронизацию, но снизит надёжность, но хрен с ними, пусть живут вместе.
6:58:24 PM Ibragim Youldachev: Ну какбэ без этого нельзя начать процесс построения ни в каком виде. ;)
7:02:20 PM Ibragim Youldachev: Кстати говоря, было бы прикольно не заставлять индексный сервер опрашивать файл, а ноды файловой системы заставлять отправлять данные индексному серверу. Т.е. файловая системы знала бы что файл индексируемый и при операциях записи фигачила бы индекс. Причём тут же. Запросы же поисковые можно отправлять map/reduce`ом к нодам файловой системы. 
7:05:18 PM Ibragim Youldachev: В принципе, можно и разделить ФС и индексацию, но всё равно писать в индексируемые файлы лучше через индексирующий сервер. Тогда управление индексом становится проще.
7:08:15 PM Олег Кац: Ничего себе, "чуть более эффективной". Ты сильно ошибаешься. Несопоставимо более эффективной.
Нет проблем – пусть первая версия прототипа работает с какой-нибудь жёстко забитой структурой.
Индексацию и ФС нельзя смешивать: во-первых, это будет тормозить запись. Во-вторых, это заставить узлы файловой системы где-то у себя хранить настройки – кому чего отправлять. 
7:09:16 PM Олег Кац: unix-way: каждая штука должна решать строго свою задачу. Узлы файловой системы должны быстро и надёжно записывать файлы или сообщать об ошибках.
7:09:33 PM Ibragim Youldachev: Почему смешивать? Не смешивать. Запись записью, а индексация индексацией. Записали -- пошли индексировать асинхронно.
7:09:56 PM Олег Кац: Кто куда пошёл? Что должен сделать узел ФС после записи?
7:10:21 PM Олег Кац: Послать сообщение через сеть? А кому?
Послать broadcast? Сеть переполнится.
7:11:40 PM Олег Кац: Писать в индексируемые файлы через индексирующий сервер тоже неправильно, потому что – а что делать, если индексирующий сервер сдох? Не писать вообще? Это неверно.
7:13:08 PM Ibragim Youldachev: Хотелось бы чтобы не приходилось постоянно опрашивать индексируемые файлы. Но фиг с ним. Пусть они опрашиваются. В конце-концов так проще.
7:13:20 PM Ibragim Youldachev: Пока, по крайне мере.
7:13:21 PM Олег Кац: Так устойчивее, это в данном случае главное. 
7:13:39 PM Олег Кац: Я могу спокойно поднять десять индексных серверов, мне это вообще ничего не будет стоить.
7:13:46 PM Олег Кац: Распараллелить клиентов между ними.
7:14:13 PM Олег Кац: А если писать через индексный, то всё уже, хуй распараллелишь, придётся решать задачу поддержания когерентности.
7:14:58 PM Олег Кац: Что плохого в постоянном опросе индексных файлов?
7:15:20 PM Ibragim Youldachev: Согласен. Именно поэтому мне хотелось бы встроить индексный сервер в ФС. Отдельным процессом. А файлу уметь писать метаинформацию. Что он индексируемый и у него такая-то структура.
7:15:59 PM Ibragim Youldachev: Но отстаивать эту точку зрения удалённо по ИМ... кажется делом затраным, потому мне придётся от этого отказаться сейчас. ;)
7:16:27 PM Ibragim Youldachev: Вот прямо чувствую как мешает IM. :)
7:16:28 PM Олег Кац: Хорошая мысль – определять на каком-нибудь языке структуру файла и ставить флаг индексируемости. Это позволит сделать индексы полностью автономными, config-free. 
7:16:59 PM Олег Кац: А я чувствую, как он упорядочивает дискуссию. Конечно, свободно болтать приятнее, только я не уверен, что содержания в такой дискусии будет больше.
7:17:13 PM Олег Кац: Слов будет больше, да. А содержания?
7:17:35 PM Олег Кац: Я щас даже запишу эту мысль про config-free
7:17:44 PM Ibragim Youldachev: язык такой назвается DDL из SQL. С точностью до трансформаций, о которых ты, правда, ни слова не сказал.
7:17:57 PM Олег Кац: НЕ слишком ли сложно?
7:18:05 PM Олег Кац: Мы не погнёмся поддерживать ВЕСЬ DDL?
7:18:28 PM Олег Кац: И не заебёмся ли описывать, какие именно фичи DDL мы поддерживаем, а какие – нет?
7:18:45 PM Ibragim Youldachev: весь не нужен. Кроме того, если движком будет-таки SQLite, то тогда вообще всё бесплатно. ;)
7:19:04 PM Олег Кац: Нет же. SQLite не будет за нас разбирать прочитанные данные.
7:20:04 PM Ibragim Youldachev: Парсер для нужного подмножества будет простым. Ну не хочется изобретать DSL на ровном месте.
7:20:47 PM Олег Кац: Ровное ли место?
Тебе надо выбрать те функции DDL, которые ты поддерживаешь, потом надо будет описать этот выбор максимально полно и непротиворечиво, чтобы остальные разработчики смогли этим пользоваться.
7:21:35 PM Олег Кац: В google для этой цели сделали, как ты говоришь, dsl
И вспомогательную библиотеку для маршалинга в обе стороны.
7:21:48 PM Олег Кац: protocol buffers называется
7:23:38 PM Ibragim Youldachev: Ну, похоже, и нам придётся. Потом. А пока надо упростить. Хочется быстро пройти нулевую фазу чтобы уже строились индексы и выполнялись запросы. Понятно же что тут управляемая сложность. А пока нет хоть чего-то работающего, то не видны недостатки решения и ничего ни проверить, ни померить, ни новых требований вспомнить/понять.
7:24:35 PM Олег Кац: Я предлагаю в качестве dsl для прототипа использовать питоновские hash-объекты.
Вот прямо так:

meta_info = {
	'O' : {type:int32,  key:True},
	'U' : {type:guid, key:True},
	'V' : {type:some_complex_struct}
}
7:24:52 PM Олег Кац: Я тут питоновский синтаксис с javascript'ом перемешал, но смысл понятен.
7:25:03 PM Ibragim Youldachev: угу. годится.
7:25:15 PM Олег Кац: Это – текстовый файл, его можно положить куда-нибудь.
7:25:19 PM Ibragim Youldachev: названия файла как минимум не хватает. ;)
7:26:01 PM Олег Кац: Ну как, у нас в ФС есть файл
/some_folder/some_file
а есть ещё
/some_folder/.some_file.meta
7:26:09 PM Олег Кац: как-нибудь так
7:26:51 PM Ibragim Youldachev: нее...
7:27:20 PM Ibragim Youldachev: серверу-то ты должен сказать чего ему индексировать.
7:27:52 PM Ibragim Youldachev: Ну т.е. так тоже можно, но что делать индексному серверу если описание без его ведома поменяли?
7:28:06 PM Олег Кац: Правильно. Я говорю серверу: ты индексируешь файл /some_folder/some_file
он идёт и читает /some_folder/some_file.meta
7:28:09 PM Ibragim Youldachev: оно же ёбнется больно.
7:28:10 PM Олег Кац: По соглашению.
7:28:20 PM Олег Кац: А по тому же соглашению метафайлы менять нельзя.
7:28:34 PM Олег Кац: Это вообще невозможно. Файл-то, который не мета, уже записан.
7:28:39 PM Ibragim Youldachev: Поэтому никакой одмин никогда такого не сделает.
7:29:19 PM Олег Кац: Короче, изменение метаинформации (читай, структуры) – незаконная операция. Да и вообще невозможная.
7:29:32 PM Олег Кац: Файлы-то все append-only. Что ты там менять собрался.
7:30:25 PM Ibragim Youldachev: хорошо, пусть будет. Но это уязвимая штука. Просто это надо запомнить.
7:30:35 PM Олег Кац: Так ведь нет тут ничего уязвимого.
7:30:50 PM Ibragim Youldachev: На трансформации забили?
7:30:58 PM Олег Кац: Нет, это следующий вопрос.
7:31:31 PM Ibragim Youldachev: Т.е. есть формат файла, а есть индекс. В индекс, насколько я понимаю, могут попасть не все поля, как минимум.
7:32:13 PM Олег Кац: Да.
7:32:24 PM Олег Кац: Но это легко решается нашим мета-объектом.
7:32:32 PM Олег Кац: вот настоящие преобразования – уже не решаются
7:32:52 PM Олег Кац: Ха, это тривиально. Кладём туда же ещё один питоновский объект – тупо процедуру преобразования :-)
7:33:07 PM Олег Кац: питон же – ничё компилировать не надо – скачал и запустил :-)
7:33:22 PM Ibragim Youldachev: Ну, надо хоть как-то понять о какого рода преобразованиях мы говорим. Может и решается. ;)
...
Опередил. ;)
7:33:39 PM Олег Кац: На С++ такой фокус не пройдёт, конечно. Но там можно будет класть скомпилированные lib-файлы.
7:33:51 PM Олег Кац: Только уже посложнее всё будет.
7:34:04 PM Ibragim Youldachev: Пусть сначала хоть что-нить заработает. ;)
7:34:06 PM Олег Кац: Да.
7:35:30 PM Ibragim Youldachev: Теперь есть ещё конфигурация сервера.
7:38:08 PM Олег Кац: Эт что?
7:39:44 PM Ibragim Youldachev: Ну как, есть сервер, который отвечает запросы и индексирует файлы. Он как минимум должен знать про файловую систему. Это если он индексирует всё. А если нет, то и файлы, которые надо индексировать.
7:40:54 PM Олег Кац: Один сервер индексирует только один файл. Это сильно упрощает дело.
7:41:03 PM Ibragim Youldachev: Кроме того, у него есть состояние. Когда последний раз сканировал ФС (если сканирует), когда последний раз обращался к файлам и на каком смещении остановился.
7:43:12 PM Ibragim Youldachev: При нештатных ситуация по смещению -- вопль в логи что паламатые и больше ничего не читать впредь до разрешения ситуации одмином.
7:43:46 PM Олег Кац: Состояние есть, и ещё snapshot'ы есть.
7:45:28 PM Ibragim Youldachev: снэпшоты пока загадка. Копировать файлы будет дорого, если они многогигабайтные.
7:45:42 PM Ibragim Youldachev: тут всё ещё буедт зависеть от выбранного движка.
7:45:57 PM Олег Кац: Да. Berkeley DB кое-что на эту тему умеет.
7:46:06 PM Олег Кац: В общем, вроде, всё.
7:47:05 PM Ibragim Youldachev: Ну, кстати, было бы здорово, если бы писали в версионируемую ФС, которую можно было бы произвольно откатывать. Тогда вообще никаких проблемов.
7:47:45 PM Ibragim Youldachev: Хотя, ты поподробнее опиши что ты понимаешь под snapshot.
7:48:49 PM Ibragim Youldachev: Может и не надо ничего? Есть же состояние. Процесс определяется только потоком чтения по смещению. Ну поднимается индексатор. Смотрит либо на смещение по которому закончил, либо на смещение с которого попросили начать. И продолжает делать своё чёрное дело.
7:49:32 PM Олег Кац: Ты работал-работал, потом взял и упал.
7:49:36 PM Олег Кац: индексный процесс
7:49:45 PM Олег Кац: Чего тебе делать? Читать все данные из файла сначала?
7:49:47 PM Олег Кац: Западло.
7:50:08 PM Олег Кац: Можно в процессе работы сохранять какие-то точки восстановления. Snapshot'ы.
7:50:15 PM Ibragim Youldachev: дык я же знаю на каком месте остановился. Записал последнее смещение о котором помню.
7:50:45 PM Олег Кац: Ну это было последнее смещение. А индекс у тебя точно в таком состоянии?
7:50:56 PM Олег Кац: А если он вообще чисто в памяти жил?
7:52:22 PM Ibragim Youldachev: Вот ссука какая. Вообще-то если под нами транзакционный движок, то если транзакция завершилась и в ней мы обновили иднекс и смещение, то всё нормуль. А если нет, то ну подохло что-то. Возьмём состояние последней успешной транзакции.
7:53:48 PM Олег Кац: Транзакционный движок тормозной.
7:53:57 PM Олег Кац: Нафик надо.
7:54:18 PM Ibragim Youldachev: Тут мы опять возвращаемся к тому, что надо больше знать про движок и ФС под нами. Так что вопрос точек восстановления надо запомнить и отложить.
7:54:46 PM Олег Кац: Угу
7:54:49 PM Ibragim Youldachev: Собственно, более-менее решение начинает оформляться.
7:55:20 PM Ibragim Youldachev: У тебя есть какие-нить вменяемые тестовые данные, которые можно будет пользовать?
7:55:44 PM Олег Кац: Нет, но они же тривиально генерируются
7:55:54 PM Ibragim Youldachev: И то правда.
7:56:12 PM Ibragim Youldachev: Ладно, что делаем дальше?

7:57:09 PM Ibragim Youldachev: Ты бы свёл в один документ то что мы тут наговорили. Чтобы противоречий не было.
7:57:21 PM Олег Кац: Нам надо склепать прототип за сегодня-завтра (в противном случае это уже не прототип, а полноценная разработка).
7:57:57 PM Ibragim Youldachev: Ну и раздал сёстрам по серьгам. В смысле определил кто что дальше делает. С учётом нашей территориальной разпределённости и того что у меня нет возможности работать с твоей распределённой ФС.
7:58:06 PM Олег Кац: Фичи, которые обязательно должны быть, иначе всё это не имеет производственной ценности:
1) http
2) чтение из реального файлового хранилища
7:58:27 PM Олег Кац: Для прототипа будет нестрашно, если он поначалу не будет уметь делать snapshot'ы
7:58:46 PM Ibragim Youldachev: Ну, кстати, http мы не обсуждали, кстати.
7:58:52 PM Ibragim Youldachev: Т.е. форму выдачи результатов.
7:59:02 PM Ibragim Youldachev: И язык запросов.
7:59:05 PM Олег Кац: Да это неважно всё вообще.
7:59:12 PM Олег Кац: http – очень простая и самоочевидная штука.
7:59:19 PM Ibragim Youldachev: Ну.. до какой-то степени, да.
7:59:32 PM Ibragim Youldachev: Короче, чё кто делать будет?
8:00:02 PM Олег Кац: Твои предложения?
Для тебя-то это развлечение, поэтому тебе и выбирать. 
8:00:07 PM Олег Кац: Я схожу кофе налью
8:01:34 PM Ibragim Youldachev: Мне пофиг, по большому счёту. Ты больше и про задачу знаешь и про окружение в котором будет прототип работать. Тебе и карты в руки. В смысле думать что я могу сделать с учётом того, что я не знаю что там у тебя за ФС и как с ней работать. Так что, лидируй давай. ;)
8:03:11 PM Ibragim Youldachev: Меня тут скоро не будет некоторое время. Ужин, панимаишь. А щас я отошёл помогать его доделывать.
8:46:45 PM Олег Кац: ФС в фиктивном виде можно без проблем развернуть и у тебя. Можно даже и не в фиктивном.
Все узлы ФС работают по http, поэтому всё разворачивается тривиально.
8:48:21 PM Олег Кац: А ФС в фиктивном виде – это просто набор http-узлов, возвращающих одно и то же, зашитое.
nc например
9:35:07 PM Ibragim Youldachev: Ну вот, я пожрал, поспал и готов поработать ;)
9:35:19 PM Олег Кац: Хорошо тебе.
9:35:23 PM Олег Кац: Давай
9:35:25 PM Ibragim Youldachev: Ты буш лидировать или как?
9:35:32 PM Олег Кац: О да, я буду сверху!
9:36:11 PM Олег Кац: Модули вырисовываются вполне очевидные.
1) Читалка из ФС. Инкапсулирует всю возню с dns, с картой, с репликами, с пропусками говна и проверками чексумм. Наружу предоставляет итератор. 
9:36:12 PM Ibragim Youldachev: ну-ну
9:37:02 PM Ibragim Youldachev: далее
9:37:33 PM Олег Кац: 2) Индекс. Просто реализует всё то, о чём мы говорили. Поиск по префиксу ключа (на выходе тоже итератор). Запись. Многопоточность.
9:38:35 PM Олег Кац: 3) http-сервер. Тупо интерфейс к индексу. Ответ выдаёт в текстовом виде, tab separated.
9:39:49 PM Олег Кац: 4) Обновлялка. Не знаю, как правильно сделать на питоне. В отдельном потоке или через какой-нибудь питоновый шедулер. Периодически просыпается, дочитывает данные (через читалку) и дописывает индекс (через его интерфейс).
9:40:41 PM Олег Кац: Это – необходимый минимум.
9:41:24 PM Олег Кац: После этого
5) Snapshots. Зависит от возможностей движка.
9:41:49 PM Олег Кац: 6) Meta info. До этого работаем с предопределённой структурой.
9:42:37 PM Олег Кац: А теперь – важная интерлюдия – я пошёл срать.
9:44:57 PM Ibragim Youldachev: спасибо за подробности.
9:46:17 PM Олег Кац: Ну чё?
9:46:31 PM Ibragim Youldachev: Далее, я думаю, нужен процесс. Либо у нас у обоих одна и та же тестовая среда, либо разный тестовый четверг. Разные задачи, разные трахи и прочие разности. Тут лучше тебе решить. Чо как.
9:47:28 PM Олег Кац: Тестовая среда – это ФС.
9:47:34 PM Ibragim Youldachev: Ага.
9:48:09 PM Ibragim Youldachev: Либо дай похожий на правду фейк, либо натоящую ФС, либо изолированную задачу.
9:48:39 PM Олег Кац: Дам фейк. Но не прямо щас, конечно.
9:48:52 PM Олег Кац: Короче, в тестовую среду будет входить фейк.
9:49:03 PM Олег Кац: Когда я его напишу =)
9:49:25 PM Ibragim Youldachev: Ну тады прямо щас с тебя репо и задача, видимо. Либо пауза пока не будет среды, в которой можно чё-нить тестить.
9:49:30 PM Олег Кац: Думаю, за остаток сегодняшнего дня напишу.
9:49:46 PM Олег Кац: Задачу выбирай сам. Мне риальни всё равно.
9:51:27 PM Ibragim Youldachev: Я пока, в принципе, могу собрать какой-нить фейковый http-отвечальник. На любой вопрос один ответ. Потом можем либо сразу взять беркли и нахерачить туда что-нить и отдавать уже оттуда. Дальше видно будет.
9:51:43 PM Олег Кац: Ога, давай. Заодно посмотришь, как там это всё устроено.

